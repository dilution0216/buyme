## 프로젝트 소개

- 수량이 정해져있는 물건을 선착순으로 재고만큼 구매할 수 있게 만든 서비스

## 프로젝트 목표

---

- 모노리스 서비스를 Docker-compose 환경에서 MSA 로 전환
- 약 10000건의 대규모 주문 트래픽 발생 시 Redis 기반 성능 최적화

## 주요 기능

---

### 1. **사용자 관리 (User Service)**

- **회원 가입**: 사용자가 회원으로 가입할 수 있는 기능
- **회원 정보 관리**: 사용자 정보의 CRUD(Create, Read, Update, Delete) 작업 지원

### 2. **상품 관리 (Product Service)**

- **상품 등록**: 새로운 상품을 등록하는 기능
- **상품 정보 수정**: 등록된 상품의 정보를 수정하는 기능
- **상품 목록 조회**: 상품 목록을 조회하는 기능
- **재고 확인**: 특정 상품의 재고 상태를 확인하는 기능

### 3. **주문 관리 (Order Service)**

- **주문 생성**: 사용자가 상품을 선택하여 주문을 생성하는 기능
- **주문 취소**: 사용자가 특정 주문을 취소할 수 있는 기능
- **주문 목록 조회**: 사용자가 자신의 주문 내역을 조회할 수 있는 기능
- **주문 반품 요청**: 사용자가 배송된 상품을 반품 요청하는 기능
- **주문 반품 완료**: 반품 처리가 완료된 주문 항목을 업데이트하는 기능
- **배송 상태 업데이트**: 주문의 배송 상태를 자동으로 업데이트하는 기능. (D+1 상태 변경 → 배송 중, D+2 상태 변경 → 배송 완료)

### 4. **결제 관리 (Payment Service)**

- **결제 시도**: 주문에 대한 결제 시도 기능 (성공/실패 확률을 적용하여 시뮬레이션)
- **결제 성공 처리**: 결제 시도가 성공했을 때 주문 상태를 **PAID**로 변경
- **결제 실패 처리**: 결제 시도가 실패했을 때 주문 상태를 **PAYMENT_FAILED**로 변경

### 5. **재고 확인 (Stock Management)**

- **실시간 재고 확인**: 상품별 재고 상태를 확인하여 재고가 부족할 때 주문을 제한하는 기능

### 6. **동시성 처리 및 락 기능**

- **낙관적 락(Optimistic Lock)**: 충돌 가능성이 낮은 상황에서 성능 최적화를 위해 적용된 락 방식
- **분산락(Redis)**: 분산된 여러 서버에서 동일한 리소스에 대한 동시성 문제를 해결하기 위한 Redis 기반 락 처리
- **락을 적용한 결제 처리**: Redis를 이용한 분산락 또는 낙관적 락을 통해, 결제 처리 시 다중 트랜잭션에서의 동시성 문제 해결

### 7. **부하 테스트 및 성능 최적화**

- **JMeter 부하 테스트**: JMeter를 사용하여 다양한 부하 테스트 시나리오를 설정하고, 대규모 트래픽 상황에서 시스템 성능을 평가
- **락 적용 전/후 성능 테스트**: 분산락과 낙관적 락 적용 전후의 성능 차이를 평가하고, 시스템 병목 현상을 분석하여 최적의 성능을 도출

## 기술 스택

---

- **mysql**
- **Spring Boot**
- **Redis**
- **Docker 및 Docker Compose**
- **JMeter**
  
## API & ERD

---

 [API 명세서](https://www.notion.so/API-82e0878c996347ed8367bb808b7975de?pvs=21) 

[ERD](https://www.notion.so/ERD-f4ef0ae9edfe4e29a84a65eed178f80f?pvs=21) 

## 성능 개선

---

https://dilution0216.tistory.com/294

## 트러블 슈팅

---

MSA 로 구조화 중 발생하는 이슈

https://dilution0216.tistory.com/278

데이터 참조 이슈

https://dilution0216.tistory.com/286

Redis- 락 사용 이슈

https://dilution0216.tistory.com/294

https://dilution0216.tistory.com/291



### 트러블슈팅

---

Redis를 이용한 분산락을 적용했을 때, 응답 시간이 증가하고 처리량이 줄어드는 성능 저하

- 원인 : 각 서비스에서 동일한 주문에 대해 동시성이슈를 막기 위해 락을 걸었지만, 대량의 요청이 몰리면서 락 획득 시간 대기 및 락 해제 과정에서 병목 현상이 발생. 락 대기 시간이 길어지면서 성능 저하
- 해결과정
    - 락 획득 대기 시간과 락 유지 시간을 조정해보았으나, 여전히 성능 문제 지속
    - 많은 트래픽이 발생하여 조회 작업이 많기 때문에, 동시 접근 성능이 좋은 낙관적 락을 사용. 이는 결제 과정에서 충돌이 자주 일어나지 않는 단순한 구조기 때문에 더욱 적합하다 판단
- 결과
    - 주문생성 응답 시간은 15~30% 의 성능 향상, 처리량은 2~30% 의 성능 향상
    - 결제처리 응답시간은 3~40%의 성능 향상, 처리량은 5%에서 30% 까지의 성능 향상

### 기술적의사결정

---

**MSA(Microservice Architecture)**

- 확장성
    - 향후 사용자와 트래픽 증가, 더 많은 비즈니스 로직 추가를 예상합니다. 각 서비스가 독립적으로 동작하는 MSA를 적용함으로써, 주문, 상품, 사용자 관리 등 각 모듈을 독립적으로 확장할 수 있습니다. 이러한 확장성은 한 서비스에 문제가 생겨도 다른 서비스에는 영향을 주지 않도록 보장할 수 있어 MSA 를 선택
- 독립적인 배포 및 유지관리
    - 각 서비스가 독립적으로 배포/관리되기 때문에 일부 모듈 변경이 생겨도 시스템에 영향을 주지 않고, 서비스는 독립적으로 유지보수 가능
- 기술스택의 다양화
    - 현 프로젝트에선 SpringBoot 기반이나, MSA 에선 각 서비스별로 다른 기술스택을 사용할 수 있음.
- 효율적인 자원 분배 가능
    - 각 서비스를 자체적으로 스케일링 하여, 성능 수요에 따라 특정 서비스만 확장/축소 가능. (ex. 결제 서비스에서 트래픽이 가장 많을 경우, 이 서비스 자원만 확장)

따라서, 현재 모노리스 서비스로 구성되어도 충분하나 확장성과 유지보수성을 고려해 MSA 구조 채택

---

**Docker Compose**

- 설정 및 관리
    - 컨테이너들을 하나의 YAML 파일로 정의하여, 서비스를 동시에 빌드하고 실행가능. 즉, 프로젝트 내 사용자 서비스, 상품 서비스, 주문 서비스, 데이터베이스(MySQL), Redis 등을 한 번에 쉽게 설정
- MSA 와 호환
    - MSA 에서 서비스들은 독립적으로 실행되는데, Docker Compose는 각 서비스를 독립된 컨테이너로 실행할 수 있게하고, 네트워크 설정을 통해 서비스 간의 통신도 용이함
- 개발환경
    - 서비스들을 동일한 네트워크에서 쉽게 연결하고 테스트 가능

대규모 서비스배포에선 쿠버네티스 같은 도구가 필요하나, 개발 초기 단계에선 Docker Compose 로도 충분하다 판단

---

**MySQL**

- 성능
    - 복잡한 쿼리 및 데이터 모델링등이 필요하다면 PostgreSQL 도 고려되나, 복잡한 기능이 요구되지 않고 간단하고 성능이 뛰어난 MySQL 채택

관계형 데이터베이스가 필요한 상황에서, 단순하고 성능이 뛰어난 MySQL 채택
